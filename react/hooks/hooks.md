##Question 1
Что делает хук useEffect?

##Answer
Выполняет побочные эффекты после рендера: фетчинг, подписка на события.
Например, если прописать в массиве зависимостей, которое идет вторым аргументом, какие-нибудь данные, то при изменении этих данных произойдет перерендер всего компонента.

##Пример
useEffect(()=>{
fetchData()
},[data])

##Question 2
Чем useEffect отличается от useLayoutEffect, и в каких случаях стоит использовать последний?

##Answer
useEffect вызывается после отрисовки и ассинхронно. useLayoutEffect вызывается на этапе инициализации компонента и синхронно, то есть после рендера но до отрисовки на странице.Его нужно использовать в случае, например, если нужно загрузить или инициализоровать конкретные данные до отображения компонента на странице. Или при изменении стиля или позиции до того как пользователь увидит разметку(иначе будет мигание)

##Question 3
Чем отличаются controlled и uncontrolled компоненты?

##Answer
Контролируемые компоненты — это элементы формы, чьё значение управляется через состояние React (useState) и обновляется через onChange. Они используют value, и React полностью контролирует ввод.

Неконтролируемые компоненты управляются самим DOM — данные берутся напрямую через ref, и React не отслеживает каждое изменение.

##Question 4
Что такое hooks? Назови и объясни хотя бы два.

##Answer
Hooks — это функции, добавленные в React для работы с функциональными компонентами. Они позволяют использовать состояние и управлять жизненным циклом без классов.

Существуют:
встроенные хуки, например useState и useEffect
кастомные хуки, которые создаёт сам разработчик для повторного использования логики

useState управляет состоянием компонента.
useEffect выполняет побочные эффекты (side effects) и вызывается после рендера компонента.

##Question 5
Как работает Virtual DOM и зачем он нужен?

##Answer
Virtual DOM — это облегчённая копия реального DOM, которую React использует для оптимизации производительности.

При каждом изменении состояния React сначала обновляет Virtual DOM.
Затем сравнивает его с предыдущей версией (diffing).
И только после этого минимально обновляет реальные изменения в real DOM (reconciliation).

Это делает интерфейс более быстрым и отзывчивым.
