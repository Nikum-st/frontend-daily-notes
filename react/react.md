##Question 1
Что делает хук useEffect?

##Answer
Выполняет побочные эффекты после рендера: фетчинг, подписка на события.
Например, если прописать в массиве зависимостей, которое идет вторым аргументом, какие-нибудь данные, то при изменении этих данных произойдет перерендер всего компонента.

##Пример
useEffect(()=>{
fetchData()
},[data])

##Question 2
Чем useEffect отличается от useLayoutEffect, и в каких случаях стоит использовать последний?

##Answer
useEffect вызывается после отрисовки и ассинхронно. useLayoutEffect вызывается на этапе инициализации компонента и синхронно, то есть после рендера но до отрисовки на странице.Его нужно использовать в случае, например, если нужно загрузить или инициализоровать конкретные данные до отображения компонента на странице. Или при изменении стиля или позиции до того как пользователь увидит разметку(иначе будет мигание)

##Question 3
Чем отличаются controlled и uncontrolled компоненты?

##Answer
Контролируемые компоненты — это элементы формы, чьё значение управляется через состояние React (useState) и обновляется через onChange. Они используют value, и React полностью контролирует ввод.

Неконтролируемые компоненты управляются самим DOM — данные берутся напрямую через ref, и React не отслеживает каждое изменение.

##Question 4
Что такое hooks? Назови и объясни хотя бы два.

##Answer
Hooks — это функции, добавленные в React для работы с функциональными компонентами. Они позволяют использовать состояние и управлять жизненным циклом без классов.

Существуют:
встроенные хуки, например useState и useEffect
кастомные хуки, которые создаёт сам разработчик для повторного использования логики

useState управляет состоянием компонента.
useEffect выполняет побочные эффекты (side effects) и вызывается после рендера компонента.

##Question 5
Как работает Virtual DOM и зачем он нужен?

##Answer
Virtual DOM — это облегчённая копия реального DOM, которую React использует для оптимизации производительности.

При каждом изменении состояния React сначала обновляет Virtual DOM.
Затем сравнивает его с предыдущей версией (diffing).
И только после этого минимально обновляет реальные изменения в real DOM (reconciliation).

Это делает интерфейс более быстрым и отзывчивым.

##Question 6
Что делает React.memo и в каких случаях его стоит применять?

##Answer
React.memo мемоизирует компонент, предотвращая его повторный рендер при тех же пропсах. Полезен для оптимизации производительности, особенно если компонент тяжёлый или часто получает одни и те же пропсы. Для правильной работы нужно, чтобы передаваемые функции были обёрнуты в useCallback, а объекты — в useMemo.

##Example
const ExpensiveComponent = React.memo(({ value }: { value: number }) => {
console.log("rendered");
return <div>{value}</div>;
});

##Question 7
Что такое "lifting state up" и зачем он используется в React?

##Answer
"Lifting state up" (поднятие состояния) — это перемещение состояния из нескольких дочерних компонентов в их общего родителя. Далее родитель управляет этим состоянием и передаёт его вниз через props.React построен на принципе однонаправленного потока данных (one-way data flow) — данные передаются сверху вниз. Поднятие состояния:

Обеспечивает согласованность (consistency) между связанными компонентами;
Позволяет избежать дублирования состояния в разных местах;
Делает логику управления данными централизованной и предсказуемой;
Упрощает отладку и поддержку.

##Question 7
Что такое key в React и зачем он нужен при рендеринге списков?

##Answer
key — это специальный атрибут, который React использует для отслеживания элементов в списке при повторном рендере. Он помогает эффективно определять, какие элементы были изменены, добавлены или удалены, без полного пересоздания DOM-структуры.

зачем нужен:
Повышает производительность, избегая лишнего перерендера.
Позволяет React сохранять и правильно обновлять состояние компонентов, привязанных к списку.

##Example
{items.map(item => (
<Item key={item.id} value={item.value} />
))}
