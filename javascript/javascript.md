##Question 1
Что произойдёт, если сравнить [] == ![] и почему?

##Answer
Будет true. Так как в данном случаем происходит нестрогое сравнение объекта с булевым значением, сначала Js переводит массив в примитив(string).Получается "" == false. Потом он переводит два операнда в один тип данных. false == false или 0 == 0

##Question 2
В чём разница между var, let и const?

##Answer
var, let и const используются для объявления переменных, но различаются по области видимости, возможности переопределения и поведению при hoisting'е:

var:
Имеет функциональную область видимости
Подвержен hoisting'у (переменная поднимается и инициализируется undefined)
Можно переопределять и переназначать

let:
Блочная область видимости
Подвержен hoisting'у, но не инициализируется — использовать до объявления нельзя
Можно переназначать, но нельзя переобъявить в одной области

const:
Блочная область видимости
Нельзя переназначить (значение фиксируется)
Объекты можно мутировать, но не переназначать саму ссылку

##Question 3
Что такое замыкание (closure) в JavaScript?

##Answer
Closure (замыкание) — это функция, которая «помнит» переменные из своей внешней (лексической) области видимости, даже если эта функция была вызвана вне этой области.
Это позволяет внутренней функции доступ к переменным родительской функции, даже после завершения выполнения родителя.В React функциональные компоненты — это замыкания: они «запоминают» значения из области, в которой были объявлены.

##Exemple
function showSum(a: number): void {
const b = 10;

function createSum(): number {
return a + b; // доступ к переменным из внешней области
}

console.log(createSum());
}

##Question 4
Чем отличаются == и ===? Когда использовать каждый?

##Answer
Оператор == выполняет нестрогое сравнение — он приводит операнды к одному типу перед сравнением.
Оператор === выполняет строгое сравнение — сравнивает и тип, и значение, без преобразования типов.

Рекомендуется всегда использовать ===, чтобы избежать неожиданных результатов при неявном преобразовании типов.

##Example
0 == '0' // true — нестрогое сравнение, строка '0' преобразуется в число
0 === '0' // false — разные типы (number vs string)

[] == ![] // true — [] приводится к "", а ![] к false, потом оба к 0
[] === ![] // false — разные типы
