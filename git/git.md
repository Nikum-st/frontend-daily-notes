##Question 1
В чём разница между git merge и git rebase

##Answer
git merge и git rebase оба используются для объединения изменений из одной ветки в другую, но делают это по-разному:

git merge: создает новый коммит слияния (merge commit), объединяя истории двух веток. История остаётся разветвлённой и сохраняет все исходные коммиты.
git rebase: "переписывает" историю, перемещая коммиты текущей ветки поверх другой. Это делает историю линейной, как будто изменения были основаны сразу на целевой ветке.

merge — безопасен, сохраняет историю, часто используется в командной разработке.
rebase — делает историю чище и линейнее, удобен перед отправкой изменений в удалённый репозиторий.

##Question 2
Что произойдёт при выполнении команды git reset --hard HEAD~1?

##Answer
Эта команда изменяет состояние репозитория, перемещая указатель HEAD на другой коммит.
делает следующее:

Команда git reset --hard HEAD~1:

1.Перемещает указатель HEAD и текущую ветку на один коммит назад (HEAD~1 — это предыдущий коммит).
2.Удаляет изменения:

    из индекса (staging area);
    из рабочей директории.

3.Все изменения, сделанные в последнем коммите, безвозвратно теряются (если только они не были сохранены где-то ещё — например, в другом бранче или stash).

Это разрушительная операция — изменения нельзя восстановить стандартными средствами, если вы их не зафиксировали или не сохранили.

##Question 3
Что происходит при выполнении команды git stash?

##Answer
Команда git stash временно сохраняет незакоммиченные изменения (в рабочей директории и индексе) в специальное хранилище и очищает рабочую директорию.

Это полезно, если нужно:

    быстро переключиться на другую ветку,
    не потеряв текущую работу.

Восстановление:

    git stash apply — применяет сохранённые изменения, но оставляет их в стэке.
    git stash pop — применяет и удаляет из стэка.

##Question 4
В чём разница между git fetch и git pull?

##Answer

- git fetch загружает изменения из удалённого репозитория, но не сливает их с текущей веткой.
- git pull = git fetch + git merge. Он сразу применяет изменения к текущей ветке.

Когда использовать:

- fetch — если хочешь сначала посмотреть, что изменилось, прежде чем объединять.
- pull — если уверен, что хочешь сразу получить и объединить обновления.

##Question 5
Что такое ветвление (branching) в Git и зачем оно используется?

##Answer
branching - возможность создавать независимые линии разработки в рамках одного репозитория. Это позволяет работать над разными частями кода одновременно, не мешая друг другу, и позже объединять эти изменения.

##Question 6
Как переименовать ветку?

##Answer
Чтобы переименовать ветку необходимо ввести:

git branch -m old_name new_name (локально)
git push origin :old_name new_name (удалено)

##Question 7
Что такое fast-forward в Git?

##Answer
fast-forward (быстрая перемотка) - тип слияния дочерней ветки и главной ветки без коммита. Просто Git перемещает указатель текущей ветки вперед, чтобы он указывал на тот же коммит, что и сливаемая ветка, не создавая отдельного коммита слияния.

Представим, что у нас есть две ветки: main и feature. Ветка feature была создана из main и с тех пор в main не было никаких новых коммитов.Находясь в ветке main, при выполнении команды git merge feature, Git увидит, что feature является прямым продолжением main, и просто перенесет указатель main на последний коммит feature. Таким образом, не будет создано нового коммита слияния, и main будет "перемотана" вперед, чтобы указать на тот же коммит, что и feature.

Преимущества fast-forward:
Более чистая история коммитов, так как нет лишних коммитов слияния.
Уменьшает размер репозитория.
Более быстрая операция слияния, так как не требуется создавать новый коммит.
